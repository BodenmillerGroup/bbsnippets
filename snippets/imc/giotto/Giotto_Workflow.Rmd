---
title: "Giotto Analysis"
author: "Nils Eling"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This script uses the recently published Giotto package to perform low- and higher-level spatial analyses on IMC data.

## Installation

The technical requirements for this package are: R (>= 3.5.1), Python (>= 3.0) and a Unix/Linux system.
To install the R version of Giotto, execute the following code.

```{r installation-1, eval=FALSE}
library(devtools)
install_github("RubD/Giotto")
```

To fully use the package, the following python packages need to be installed:

```{r installation-2, eval=FALSE}
# pandas:
conda install -c anaconda pandas

# python-igraph:
conda install -c conda-forge python-igraph
conda install -c conda-forge/label/gcc7 python-igraph
conda install -c conda-forge/label/cf201901 python-igraph 

# networkx:
conda install -c anaconda networkx

# louvain:
conda install -c conda-forge python-louvain
conda install -c conda-forge/label/gcc7 python-louvain
conda install -c conda-forge/label/cf201901 python-louvain

# leidenalg:
conda install -c conda-forge leidenalg
```

Finally, in order to use the hidden markov random field approach as explained [here](https://www.nature.com/articles/nbt.4260), the following R package needs to be installed:

```{r installation-3, eval=FALSE}
install_bitbucket("qzhudfci/smfishhmrf-r", ref="default")
```

The package can now be loaded:

```{r load-package}
library(Giotto)
```

## Reading in the data

In the first instance, we want to create the `giotto` R object, which is an S4 class object storing all relevant metadata.
As an example, I will use the cell data from a single image generated for the Damond _et al._ paper available [here](https://www.sciencedirect.com/science/article/pii/S1550413118306910#sec4).

First, we will read in the cell-level ion counts.

```{r read-data}
if(!file.exists("All_Cells.csv")){
  download.file(url = "https://data.mendeley.com/datasets/cydmwsfztj/1/files/bf3c4c19-7105-460d-b348-67bed6a29ed5/Cells.7z?dl=1",
              destfile = "Cells.7z")
  system('7z e Cells.7z')
  file.remove("Cells.7z")
}

# Read in the cell-level counts
library(data.table)
cells <- fread("All_Cells.csv")
```

For convenience, we will only run Giotto on one single image.

```{r select-image}
cells <- cells[cells$ImageNumber == "1",]
```

We will next link all available metadata to the selected image.
The image numbers saved in the All_Cells.csv file correspond to the CellProfiler (CP) output.
To link the CP image numbers to the actual image numbers, a metadata file is available.

```{r metadata}
# Image metadata
if(!file.exists("All_Cells.csv")){
  download.file(url = "https://data.mendeley.com/datasets/cydmwsfztj/1/files/540455ba-3253-4f9b-b49f-c24542563da5/Image.7z?dl=1",
              destfile = "Image.7z")
  system('7z e Image.7z')
  file.remove("Image.7z")
}
image.meta <- read.csv("All_Image.csv")

# Retrieve the actual image number
image.number <- image.meta[image.meta$ImageNumber == unique(cells$ImageNumber),"Metadata_Core"]
image.number
```

In the next step, we need to find the patient that corresponds to the retrieved image.
For this, a metadata file that contains the link between patients and images is available.

```{r patient-data}
patient.meta <- read.csv(file = url("https://data.mendeley.com/datasets/cydmwsfztj/1/files/fd3aae49-310e-4f0f-b92d-7ba2fad8aead/Metadata.csv?dl=1"))

# Retrieve patient
patient.number <- patient.meta[patient.meta$image == image.number,"case"]
patient.number
```

We will next download the associated images to this patient.

```{r images}
# Image data
if(!file.exists("A01_a0_full.tiff")){
  download.file(url = "https://data.mendeley.com/datasets/cydmwsfztj/1/files/e7a01a41-37c5-4d22-b69e-e8f3516c097c/6362.7z?dl=1",
              destfile = "6362.7z")
  system('7z e 6362.7z')
  file.remove("6362.7z")
  system("find . ! -name 'A01_a0_full.tiff' -name '*full*' -type f -exec rm -f {} +")
}
```

Lastly, we will read in the dataframe that links the protein names to the individual channels.

```{r panel}
panel <- read.csv(file = url("https://data.mendeley.com/datasets/cydmwsfztj/1/files/852bc00d-d72f-4772-a460-b820b98da3c6/Panel.csv?dl=1"))
```

We now obtained all files necessary to work with Giotto.


## Prepare data

In this section, we will slightly modify the obtained data to create a `Giotto` S4 object.
First, we will need to split the raw counts from the additional metadata files.

```{r select-metadata}
# First, we will select the raw counts
raw.counts <- as.matrix(cells)[,grepl("Intensity_MeanIntensity_CleanStack_", colnames(cells))]

# Rename the columns to include the protein names
colnames(raw.counts) <- panel[as.numeric(sub("^.*c", "", colnames(raw.counts))),"clean_Target"]

# To use the raw counts with giotto, we need to transpose the matrix and add column names
raw.counts <- t(raw.counts)
colnames(raw.counts) <- as.character(seq(1,ncol(raw.counts)))

# Now, select the metadata
metadata <- as.data.frame(cells)[,!grepl("Intensity_MeanIntensity_CleanStack_", colnames(cells))]
```

## Create the Giotto object

Next, we will store the raw counts and metadata into a `Giotto` S4 class object.
For this, we can use the `createGiottoObject` wrapper function.
At this point, it is more robust to create a `data.frame` containing the spatial locations rather than a `data.table`.

```{r giotto-wrapper}
# Create Giotto object
goobject <- createGiottoObject(raw_exprs = raw.counts,
                               spatial_locs = data.frame(x = metadata$Location_Center_X, 
                                                            y = metadata$Location_Center_Y))
# Generic show method
goobject

# Giotto specific method to print object
print.giotto(goobject)
```

Furthermore, the cell and protein metadata can be stored within the `Giotto` object.

For this, the `addCellMetadata` and `addGeneMetadata` wrapper functions can be used.

```{r add-metadata}
# Add cell metadata
goobject <- addCellMetadata(goobject, as.data.table(metadata))

# Add gene metadata
goobject <- addGeneMetadata(goobject, as.data.table(panel[match(rownames(raw.counts), panel$clean_Target),]))
```

Alternatively, these slots can be added directly when creating the Giotto object.

```{r giotto-meta}
# Create Giotto object
goobject <- createGiottoObject(raw_exprs = raw.counts,
                               spatial_locs = data.frame(x = metadata$Location_Center_X, 
                                                            y = metadata$Location_Center_Y), 
                               cell_metadata = as.data.table(metadata), 
                               gene_metadata = as.data.table(panel[match(rownames(raw.counts), panel$clean_Target),]))
# Print method
print.giotto(goobject)
```

# Low-level functions for data accession

In this paragraph, I will highlight accessor functions to be used on the Giotto object.

```{r feature-extraction}
# Select cell metadata
head(pDataDT(goobject))

# Gene metadata
head(fDataDT(goobject))
```

The `Giotto` object allows storing multiple 'assays' which can be the following: raw ion counts, normalized ion counts, scaled ion counts amd custom ion counts.
These slots can be accessed using the `select_expression_values` function.

```{r select_expression_values}
# Raw counts
dim(select_expression_values(gobject = goobject, values = "raw"))

# Normalized counts - not included in the object
dim(select_expression_values(gobject = goobject, values = "normalized"))
```

The `Giotto` object can be subsetted using the `subsetGiotto` function.

```{r subsetGiotto}
subsetGiotto(goobject, cell_ids = seq(1,1000), gene_ids = c("H3", "CD20"))
```

# Quality control 

`filterDistributions` and `filterCombinations` and `filterGiotto`


# Normalization

`normalizeGiotto`, `adjustGiottoMatrix` for batch effect removal

# Clustering

Clustering

`annotateGiotto` for annotation

`create_average_DT` and `create_average_detection_DT`


## Session Info

```{r session-info}
sessionInfo()
```